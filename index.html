<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sintetizador Web Básico</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: sans-serif;
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  #controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
  }
  button.wave-btn {
    width: 60px;
    height: 60px;
    background-color: #222;
    border: 2px solid #0f0;
    border-radius: 8px;
    cursor: pointer;
    color: #0f0;
    font-weight: bold;
  }
  button.wave-btn.selected {
    box-shadow: 0 0 10px 3px #0f0;
  }
  label {
    font-size: 14px;
    color: #0f0;
  }
  input[type=range] {
    width: 120px;
  }
  #oscilloscope {
    background: #000;
    border: 1px solid #0f0;
  }
</style>
</head>
<body>

<h1>Sintetizador Web Básico</h1>

<div id="controls">
  <div>
    <label>Tipo de Onda</label><br/>
    <button class="wave-btn selected" data-wave="sine">Sine</button>
    <button class="wave-btn" data-wave="square">Square</button>
    <button class="wave-btn" data-wave="sawtooth">Saw</button>
    <button class="wave-btn" data-wave="triangle">Triangle</button>
    <button class="wave-btn" data-wave="white">Noise</button>
  </div>
  <div>
    <label for="volume">Volumen</label><br/>
    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.5">
  </div>
  <div>
    <label for="transpose">Transposición (semitonos)</label><br/>
    <input type="range" id="transpose" min="-24" max="24" step="1" value="0">
  </div>
  <div>
    <label for="attack">Attack</label><br/>
    <input type="range" id="attack" min="0" max="1" step="0.01" value="0.05">
  </div>
  <div>
    <label for="decay">Decay</label><br/>
    <input type="range" id="decay" min="0" max="1" step="0.01" value="0.3">
  </div>
  <div>
    <label for="sustain">Sustain</label><br/>
    <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
  </div>
  <div>
    <label for="release">Release</label><br/>
    <input type="range" id="release" min="0" max="3" step="0.01" value="0.5">
  </div>
</div>

<canvas id="oscilloscope" width="600" height="100"></canvas>

<p>Usa las teclas ASDFGHJKL para tocar notas.</p>

<script>
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const analyser = ctx.createAnalyser();
  analyser.fftSize = 2048;
  const dataArray = new Uint8Array(analyser.fftSize);
  const canvas = document.getElementById('oscilloscope');
  const canvasCtx = canvas.getContext('2d');

  // Mapa teclas a frecuencias (octava central)
  const keyToFreq = {
    a: 261.63, // C4
    s: 293.66, // D4
    d: 329.63, // E4
    f: 349.23, // F4
    g: 392.00, // G4
    h: 440.00, // A4
    j: 493.88, // B4
    k: 523.25, // C5
    l: 587.33  // D5
  };

  let selectedWave = 'sine';
  let transpose = 0;
  const pressedKeys = {};

  // Función para actualizar selección de onda
  document.querySelectorAll('button.wave-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      selectedWave = btn.dataset.wave;
      document.querySelectorAll('button.wave-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
    });
  });

  // Función para reactivar AudioContext al primer uso (por autoplay policy)
  function resumeAudioContext() {
    if (ctx.state === 'suspended') {
      ctx.resume();
    }
  }

  function createNoiseBuffer() {
    const buffer = ctx.createBuffer(1, ctx.sampleRate * 1, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    return buffer;
  }
  const noiseBuffer = createNoiseBuffer();

  function playNote(key) {
    if (pressedKeys[key]) return; // ya suena
    const baseFreq = keyToFreq[key];
    if (!baseFreq) return;

    resumeAudioContext();

    const freq = baseFreq * Math.pow(2, transpose / 12);

    const now = ctx.currentTime;

    // Parámetros ADSR
    const attack = parseFloat(document.getElementById('attack').value);
    const decay = parseFloat(document.getElementById('decay').value);
    const sustain = parseFloat(document.getElementById('sustain').value);
    const release = parseFloat(document.getElementById('release').value);
    const volume = parseFloat(document.getElementById('volume').value);

    const gainNode = ctx.createGain();
    gainNode.gain.setValueAtTime(0, now);

    let source;
    if (selectedWave === 'white') {
      source = ctx.createBufferSource();
      source.buffer = noiseBuffer;
      source.loop = true;
    } else {
      source = ctx.createOscillator();
      source.type = selectedWave;
      source.frequency.setValueAtTime(freq, now);
    }

    source.connect(gainNode).connect(analyser).connect(ctx.destination);

    source.start(now);

    // ADSR envelope
    gainNode.gain.linearRampToValueAtTime(volume, now + attack);
    gainNode.gain.linearRampToValueAtTime(volume * sustain, now + attack + decay);

    pressedKeys[key] = { source, gainNode, release };

  }

  function stopNote(key) {
    if (!pressedKeys[key]) return;
    const { source, gainNode, release } = pressedKeys[key];
    const now = ctx.currentTime;

    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
    gainNode.gain.linearRampToValueAtTime(0, now + release);

    source.stop(now + release + 0.05);

    setTimeout(() => {
      gainNode.disconnect();
      source.disconnect();
      delete pressedKeys[key];
    }, (release + 0.1) * 1000);
  }

  function drawOscilloscope() {
    requestAnimationFrame(drawOscilloscope);

    analyser.getByteTimeDomainData(dataArray);

    canvasCtx.fillStyle = '#000';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    canvasCtx.lineWidth = 2;
    canvasCtx.strokeStyle = '#0f0';

    canvasCtx.beginPath();

    const sliceWidth = canvas.width / analyser.fftSize;
    let x = 0;

    for (let i = 0; i < analyser.fftSize; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * canvas.height / 2;
      if (i === 0) {
        canvasCtx.moveTo(x, y);
      } else {
        canvasCtx.lineTo(x, y);
      }
      x += sliceWidth;
    }
    canvasCtx.lineTo(canvas.width, canvas.height / 2);
    canvasCtx.stroke();
  }

  drawOscilloscope();

  document.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (keyToFreq[key]) {
      playNote(key);
    }
  });

  document.addEventListener('keyup', e => {
    const key = e.key.toLowerCase();
    if (keyToFreq[key]) {
      stopNote(key);
    }
  });

  document.getElementById('transpose').addEventListener('input', e => {
    transpose = parseInt(e.target.value);
  });

</script>

</body>
</html>
